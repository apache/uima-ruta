<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"[
<!ENTITY imgroot "images/tools/tools.textmarker/" >
<!ENTITY % uimaents SYSTEM "../../target/docbook-shared/entities.ent" >  
%uimaents;
]>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<chapter id="ugr.tools.tm">
	<title>TextMarker User&apos;s Guide</title>
	<titleabbrev>TextMarker User&apos;s Guide</titleabbrev>

	<section id="ugr.tools.tm.introduction">
		<title>TextMarker</title>
		<para>The TextMarker system is an open source tool
			for the development
			of rule-based information extraction applications.
			The development
			environment is based on the DLTK framework. It
			supports the knowledge
			engineer with a full-featured rule editor,
			components for the
			explanation of the rule inference and a build
			process for generic UIMA
			Analysis Engines and Type Systems.
			Therefore TextMarker components can
			be easily created and combined
			with other UIMA components in different
			information extraction
			pipelines rather flexibly.

			TextMarker applies a
			specialized rule representation language for the effective
			knowledge
			formalization:
			The rules of the TextMarker language are composed of a
			list of rule
			elements that themselves consists of four parts: The
			mandatory
			matching condition establishes a connection to the input
			document by
			referring to an already existing concept, respectively
			annotation.
			The
			optional quantifier defines the usage of the matching
			condition
			similar to regular expressions. Then, additional conditions
			add
			constraints to the matched text fragment and additional actions
			determine the consequences of the rule. Therefore, TextMarker rules
			match on a pattern of given annotations and, if the additional
			conditions evaluate true, then they execute their actions, e.g.
			create
			a new annotation. If no initial annotations exist, for example,
			created by another component, a scanner is used to seed simple token
			annotations contained in a taxonomy.

			The TextMarker system provides
			unique functionality that is usually not
			found in similar systems. The
			actions are able to modify the document
			either by replacing or
			deleting text fragments or by filtering the
			view on the document. In
			this case, the rules ignore some
			annotations,
			e.g. HTML markup, or are
			executed only on the remaining text passages.
			The knowledge engineer
			is able to add heuristic knowledge by using
			scoring rules.
			Additionally, several language elements common to
			scripting languages
			like conditioned statements, loops, procedures,
			recursion, variables
			and expressions increase the expressiveness of
			the language. Rules are
			able to directly invoke external rule sets or
			arbitrary UIMA Analysis
			Engines and foreign libraries can be
			integrated with the extension
			mechanism for new language elements.

		</para>
		<section id="ugr.tools.tm.introduction.metaphor">
			<title>Introduction</title>
			<para>
				In manual information extraction humans often apply a strategy
				according to a highlighter metaphor: First relevant headlines are
				considered and classified according to their content by coloring
				them
				with different highlighters. The paragraphs of the annotated
				headlines
				are then considered further. Relevant text fragments or
				single words
				in the context of that headline can then be colored. In
				this way, a
				top-down analysis and extraction strategy is implemented.
				Necessary
				additional information can then be added that either refers
				to other
				text segments or contains valuable domain specific
				information.
				Finally the colored text can be easily analyzed
				concerning the
				relevant information.

				The TextMarker system (textmarker
				is a common german word for a
				highlighter) tries to imitate this
				manual extraction method by
				formalizing the appropriate actions using
				matching rules: The rules
				mark sequences of words, extract text
				segments or modify the input
				document depending on textual
				features.The default input for the
				TextMarker system is
				semi-structured text, but it can also process
				structured or free
				text. Technically, HTML is often the input
				format,
				since most word
				processing documents can be converted to HTML.
				Additionally, the
				TextMarker systems offers the possibility to
				create
				a modified output
				document.
			</para>
		</section>
		<section id="ugr.tools.tm.introduction.concepts">
			<title>Core Concepts</title>
			<para>
				As a first step in the extraction process the TextMarker system uses
				a
				tokenizer (scanner) to tokenize the input document and to create a
				stream of basic symbols. The types and valid annotations of the
				possible tokens are predefined by a taxonomy of annotation types.
				Annotations simply refer to a section of the input document and
				assign a type or concept to the respective text fragment. The figure
				on the right shows an excerpt of a basic annotation taxonomy: CW
				describes all tokens, for example, that contains a single word
				starting with a capital letter, MARKUP corresponds to HTML or XML
				tags, and PM refers to all kinds of punctuations marks. Take a look
				at [basic annotations|BasicAnnotationList] for a complete list of
				initial annotations.


				<screenshot>
					<mediaobject>
						<imageobject>
							<imagedata scale="80" format="PNG" fileref="&imgroot;symboltaxo.png" />
						</imageobject>
						<textobject>
							<phrase>Part of a taxonomy for basic annotation types.</phrase>
						</textobject>
					</mediaobject>
				</screenshot>

				By using (and extending) the taxonomy, the knowledge engineer is
				able
				to choose the most adequate types and concepts when defining new
				matching rules, i.e., TextMarker rules for matching a text fragment
				given by a set of symbols to an annotation. If the capitalization of
				a word, for example, is of no importance, then the annotation type W
				that describes words of any kind can be used. The initial scanner
				creates a set of basic annotations that may be used by the matching
				rules of the TextMarker language. However, most information
				extraction applications require domain specific concepts and
				annotations. Therefore, the knowledge engineer is able to extend the
				set of annotations, and to define new annotation types tuned to the
				requirements of the given domain. These types can be flexibly
				integrated in the taxonomy of annotation types.

				One of the goals in
				developing a new information extraction language
				was
				to maintain an
				easily readable syntax while still providing a
				scalable
				expressiveness of the language. Basically, the TextMarker
				language
				contains expressions for the definition of new annotation
				types and
				for defining new matching rules. The rules are defined by a
				list of
				rule elements.
				Each rule element contains at least a basic matching
				condition referring
				to text fragments or already specified
				annotations. Additionally a
				list of conditions and actions may be
				specified for a rule element.
				Whereas the conditions describe
				necessary attributes of the matched
				text fragment, the actions point
				to operations and assignments on
				the
				current fragments. These actions
				will then only be executed if all
				basic conditions matched on a text
				fragment or the annotation and the
				related conditions are fulfilled.
			</para>
		</section>
		<section id="ugr.tools.tm.introduction.examples">
			<title>Examples</title>
			<para>
				The usage of the language and its readability can be demonstrated by
				simple examples:

				<programlisting><![CDATA[
					CW{INLIST('animals.txt') -> MARK(Animal)};
					Animal "and" Animal{-> MARK(Animalpair, 1, 2, 3)};
        ]]></programlisting>

				The first rule looks at all capitalized words that are listed in an
				external document animals.txt and creates a new annotation of the
				type
				animal using the boundaries of the matched word. The second rule
				searches for an annotation of the type animal followed by the
				literal
				and and a second animal annotation. Then it will create a new
				annotation animalpair covering the text segment that matched the
				three
				rule elements (the digit parameters refer to the number of
				matched
				rule element).

				<programlisting><![CDATA[
					Document{-> MARKFAST(Firstname, 'firstnames.txt')};
					Firstname CW{-> MARK(Lastname)};
					Paragraph{VOTE(Firstname, Lastname) -> LOG("Found more Firstnames than Lastnames")};
      	]]></programlisting>

				In this example, the first rule annotates all words that occur in
				the
				external document firstnames.txt with the type firstname. The
				second
				rule creates a lastname annotation for all capitalized word
				that
				follow a firstname annotation. The last rule finally processes
				all
				paragraph} annotations. If the VOTE condition counts more
				firstname
				than lastname annotations, then the rule writes a log entry
				with a
				predefined message.


				<programlisting><![CDATA[
					ANY+{PARTOF(Paragraph), CONTAINS(Delete, 50, 100, true) -> MARK(Delete)};
					Firstname{-> MARK(Delete,1 , 2)} Lastname;
					Delete{-> DEL};
				]]></programlisting>

				Here, the first rule looks for sequences of any kind of tokens
				except
				markup and creates one annotation of the type delete for each
				sequence, if the tokens are part of a paragraph annotation and
				contains together already more than 50% of delete annoations. The +
				signs indicate this greedy processing. The second rule annotates
				first
				names followed by last names with the type delete and the third
				rule
				simply deletes all text segments that are associated with that
				delete
				annotation.

			</para>
		</section>
		<section id="ugr.tools.tm.introduction.features">
			<title>Special Features</title>
			<para>
				The TextMarker language features some special characteristics
				that are
				usually not found in other rule-based information extraction
				systems
				or even shift it towards scripting languages. The possibility
				of
				creating new annotation types and integrating them into the
				taxonomy
				facilitates an even more modular development of information
				extraction systems.

				Read more about robust extraction using
				filtering, complex control
				structures and heuristic extraction using
				scoring rules.
			</para>
		</section>
		<section id="ugr.tools.tm.introduction.getstarted">
			<title>Get started</title>
			<para>
				This section page gives you a short, technical introduction on
				how to
				get
				started with TextMarker system and mostly just links the
				information
				of the other wiki pages. Some knowledge about the usage
				of Eclipse and
				central concepts of UIMA are useful. TextMarker
				consists of the
				TextMarker rule language (and of course the rule
				inference) and the
				TextMarker workbench. Additionally, the CEV plugin
				is used to edit
				and
				visualize annotated text. The TextRuler system
				with implementations of
				well known rule learning methods and
				development extension with
				support for test-driven development are
				already integrated.
			</para>
			<section id="ugr.tools.tm.introduction.getstarted.running">
				<title>Up and running</title>
				<para>
					First of all, install the Workbench and read the introduction
					and its
					examples. In order to verify if the Workbench is correctly
					installed,
					take a look at Help-About Eclipse-Installation Details
					and compare
					the installed plugins with the plugins you copied into
					the plugins
					folder of your Eclipse application. Normally most of the
					plugins do
					not cause any troubles, but the CEV does because of the
					XPCom and
					XULRunner dependencies. You should at least get the XPCom
					plugin up
					and running. However, you cannot use the additional HTML
					functionality without the XULRunner plugin. If the plugins of the
					installation guide do not work properly and a google search for a
					suiteable plugin is not successful, then write a mail to the user
					list and we will try to solve the problem. If all plugins are
					correctly installed, then start the Eclipse application and switch
					to
					the TextMarker perspective (Window-Open Perspective-Other...)
				</para>
			</section>
			<section id="ugr.tools.tm.introduction.getstarted.example">
				<title>Learn by example</title>
				<para>
					Having a running Workbench download the example project and
					import/copy
					this TextMarker project into your workspace. The project
					contains
					some simple rules for extraction the author, title and year
					of
					reference strings. Next, take a look at the project structure and
					the
					syntax and compare it with the example project and its contents.
					Open
					the Main.tm TextMarker script in the folder
					script/de.uniwue.example
					and press the Run button in the Eclipse
					toolbar. The docments in
					the
					input folder will then be processed by
					the Main.tm file and the
					result of the information extraction task
					is placed in the output
					folder. As you can see, there are four
					files: an xmiCAS for each
					input file and a HTML file (the
					modifed/colored result). Open one of
					the .xmi files with the CAS
					Editor plugin (-popup menu-Open with) and
					select some checkboxes in
					the Annotation Browser view.
				</para>
			</section>
			<section id="ugr.tools.tm.introduction.getstarted.doit">
				<title>Do it yourself</title>
				<para>
					Try to write some rules yourself. Read the description of the
					available
					language constructs, e.g., conditions and actions and use
					the
					explanation component in order to take a closer look at the rule
					inference. Then finally, read the rest of this document.
				</para>
			</section>
		</section>
	</section>
	<section id="ugr.tools.tm.language">
		<title>TextMarker Language</title>
		<para>

		</para>

		<section id="ugr.tools.tm.seeding">
			<title>Basic Annotations and tokens</title>
			<para>
				The TextMarker system uses a JFlex lexer to initially create a
				seed of
				basic, token annotations.
			</para>
		</section>
		<section id="ugr.tools.tm.syntax">
			<title>Syntax</title>
			<para>
				Structure
				<programlisting><![CDATA[<![CDATA[
			script                 -> packageDeclaration globalStatements statements
			packageDeclaration     -> "PACKAGE" DottedIdentifier ";"
			globalStatments        -> globalStatment*   
			globalStatment         -> ("TYPESYSTEM" | "SCRIPT" | "ENGINE") DottedIdentifier ";"
			statements             -> statement*
			statement              -> typeDeclaration | resourceDeclaration | variableDeclaration 
			                          | blockDeclaration | simpleStatement
			]]></programlisting>

			Declarations
			<programlisting><![CDATA[
			typeDeclaration        -> "DECLARE" (AnnotationType)? Identifier ("," Identifier )*
			                          | "DECLARE" AnnotationType Identifier ( "(" featureDeclaration ")" )?
			featureDeclaration     -> ( (AnnotationType | "STRING" | "INT" | "DOUBLE" | "BOOLEAN") Identifier)+
			resourceDeclaration    -> ("WORDLIST" Identifier = listExpression | "WORDTABLE" Identifier = tableExpression)  ";"
			variableDeclaration    -> ("TYPE" | "STRING" | "INT" | "DOUBLE" | "BOOLEAN") Identifier ";"
			]]></programlisting>
				More information about Declarations.

				Statements
				<programlisting><![CDATA[
			blockDeclaration       -> "BLOCK" "(" Identifier ")" ruleElementWithType "{" statements "}"
			simpleStatement        -> ruleElements ";"
			ruleElements           -> ( ruleElementWithLiteral  | ruleElementWithType )+
			ruleElementWithLiteral -> simpleStringExpression quantifierPart? conditionActionPart?
			ruleElementWithType    -> typeExpression quantifierPart? conditionActionPart?
			quantifierPart         -> "*" | "*?" | "+" | "+?" | "?" | "??" 
			                          | "[" numberExpression "," numberExpression "]"
			                          | "[" numberExpression "," numberExpression "]?"
			                          
			conditionActionPart    -> "{" (condition ( "," condition )*)? ( "->" (action( "," action)*))? "}"        
			condition              -> ConditionName ("(" argument ("," argument)* ")")?
			action                 -> ActionName ("(" argument ("," argument)* ")")?
			]]></programlisting>
				More information about Quantifiers,
				Conditions, Actions and Blocks.
				The ruleElementWithType of a BLOCK declaration must have opening
				and
				closing curly brackets (e.g., BLOCK(name) Document{} {...})

				Expressions
				<programlisting><![CDATA[
			argument                   -> typeExpression | numberExpression | stringExpression | booleanExpression
			typeExpression             -> AnnotationType | TypeVariable
			numberExpression           -> additiveExpression
			additiveExpression         -> multiplicativeExpression
			multiplicativeExpression   -> simpleNumberExpression ( ( "*" | "/" | "%" ) simpleNumberExpression )*
			                              | ( "EXP" | "LOGN" | "SIN" | "COS" | "TAN" ) numberExpressionInPar
			numberExpressionInPar      -> "(" additiveExpression ")"
			simpleNumberExpression     -> "-"? ( DecimalLiteral | FloatingPointLiteral | NumberVariable)
			                              | numberExpressionInPar      
			stringExpression           -> simpleStringExpression ( "+" simpleSEOrNE )*                   
			simpleStringExpression     -> StringLiteral | StringVariable
			simpleSEOrNE               -> simpleStringExpression | numberExpressionInPar
			booleanExpression          -> booleanNumberExpression | BooleanVariable | BooleanLiteral
			booleanNumberExpression    -> "(" numberExpression ( "<" | "<=" | ">" | ">=" | "==" | "!=" ) numberExpression ")"
			listExpression             -> Identifier | ResourceLiteral
			tableExpression            -> Identifier | ResourceLiteral
			]]></programlisting>
				More information about Expressions. A ResourceLiteral
				is something
				like 'folder/file.txt' (yes, with single quotes).
			</para>
		</section>
		<section id="ugr.tools.tm.inference">
			<title>Syntax</title>
			<para>
				The inference relies on a complete, disjunctive partition of the
				document. A basic (minimal) annotation for each element of the
				partition is assigned to a type of a hierarchy. These basic
				annotations are enriched for performance reasons with information
				about annotations that start at the same offset or overlap with the
				basic annotation. Normally, a scanner creates a basic annotation for
				each token, punctuation or whitespace, but can also be replaced with
				a different annotation seeding strategy. Unlike other rule-based
				information extraction language, the rules are executed in an
				imperative way. Experience has shown that the dependencies between
				rules, e.g., the same annotation types in the action and in the
				condition of a different rule, often form tree-like and not
				graph-like structures. Therefore, the sequencing and imperative
				processing did not cause disadvantages, but instead obvious
				advantages, e.g., the improved understandability of large rule sets.
				The following algorithm summarizes the rule inference:
				<programlisting><![CDATA[
collect all basic annotations that fulfill the first matching condition
  for all collected basic annotations do
    for all rule elements of current rule do
    if quantifier wants to match then
      match the conditions of the rule element on the current basic annotation
      determine the next basic annotation after the current match
      if quantifier wants to continue then
        if there is a next basic annotation then
          continue with the current rule element and the next basic annotation
        else if rule element did not match then
          reset the next basic annotation to the current one
      set the current basic annotation to the next one
      if some rule elements did not match then
        stop and continue with the next collected basic annotation
      else if there is no current basic annotation and the quantifier wants to continue then
        set the current basic annotation to the previous one
  if all rule elements matched then
    execute the actions of all rule elements
]]></programlisting>
				The rule elements can of course match on all kinds of annotations.
				Therefore the determination of the next basic annotation returns the
				first basic annotation after the last basic annotation of the
				complete, matched annotation.

			</para>
		</section>
		<section id="ugr.tools.tm.declarations">
			<title>Declarations</title>
			<para>

				There are three different kinds declaration in the TextMarker
				system:
				Declarations of types with optional feature definitions of
				that type,
				declaration of variables and declarations for importing
				external
				resources, scripts of UIMA components.
			</para>
			<section id="ugr.tools.tm.declarations.type">
				<title>Type</title>
				<para>
					Type declarations define new kinds of annotations types and
					optionally its features.

					Examples:
					<programlisting><![CDATA[
			DECLARE SimpleType1, SimpleType2; // <- two new types with the parent type "Annotation"
			DECLARE ParentType NewType (SomeType feature1, INT feature2); // <- defines a new type "NewType" 
			    // with parent type "ParentType" and two features
			]]></programlisting>

					If the parent type is not defined in the same namepace, then the
					complete namespace has to be used, e.g., DECLARE
					my.other.package.Parent NewType;
				</para>
			</section>
			<section id="ugr.tools.tm.declarations.variable">
				<title>Variable</title>
				<para>
					Variable declarations define new variables. There are five kinds of
					variables:
					* Type variable: A variable that represents an annotation
					type.
					* Integer variable: A variable that represents a integer.
					*
					Double variable: A variable that represents a floating-point
					number.
					* String variable: A variable that represents a string.
					*
					Boolean
					variable: A variable that represents a boolean.

					Examples:
					<programlisting><![CDATA[
				TYPE newTypeVariable;
				INT newIntegerVariable;
				DOUBLE newDoubleVariable;
				STRING newStringVariable;
				BOOLEAN newBooleanVariable;
				]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.declarations.ressource">
				<title>Resources</title>
				<para>

					There are two kinds of resource declaration, that make external
					resources available in hte TextMarker system:
					* List: A list
					represents a normal text file with an entry per line
					or a compiled
					tree of a word list.
					* Table: A table represents comma separated
					file.

					Examples:
					<programlisting><![CDATA[
				LIST Name = 'someWordList.txt';
				TABLE Name = 'someTable.csv';
				]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.declarations.scripts">
				<title>Scripts</title>
				<para>

					Additional scripts can be imported and reused with the CALL action.
					The types of the imported rules are then also available, so that it
					is not neccessary to import the Type System of the additional rule
					script.

					Examples:
					<programlisting><![CDATA[
				SCRIPT my.package.AnotherScript; // <- "AnotherScript.tm" in the "my.package" package
				Document{->CALL(AnotherScript)}; // <- rule executes "AnotherScript.tm"
				]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.declarations.components">
				<title>Components</title>
				<para>

					There are two kind of UIMA components that can be imported in a
					TextMarker script:
					* Type System: includes the types defined in an
					external type system.
					* Analysis Engine: makes an external analysis
					engine available. The
					type system needed for the analysis engine has
					to be imported
					seperately. Please mind the filtering setting when
					calling an
					external analysis engine.

					Examples:
					<programlisting><![CDATA[
				ENINGE my.package.ExternalEngine; // <- "ExternalEngine.xml" in the 
				    // "my.package" package (in the descriptor folder)
				TYPESYSTEM my.package.ExternalTypeSystem; // <- "ExternalTypeSystem.xml" 
				    // in the "my.package" package (in the descriptor folder)
				Document{->RETAINTYPE(SPACE,BREAK),CALL(ExternalEngine)}; 
				    // calls ExternalEngine, but retains white spaces
				]]></programlisting>

				</para>
			</section>
		</section>
		<section id="ugr.tools.tm.quantifier">
			<title>Quantifiers</title>
			<para>
			</para>
			<section id="ugr.tools.tm.quantifier.sg">
				<title>* Star Greedy</title>
				<para>
					The Star Greedy quantifier matches on any amount of annotations and
					evaluates always true. Please mind, that a rule element with a Star
					Greedy quantifier needs to match on different annotations than the
					next rule element.

					Examples:
					<programlisting><![CDATA[
				Input:    small Big Big Big small
				Rule:     CW*
				Matched:  Big Big Big  
				Matched:  Big Big 
				Matched:  Big
				]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.quantifier.sr">
				<title>*? Star Reluctant</title>
				<para>
					The Star Reluctant quantifier matches on any amount of annotations
					and evaluates always true, but stops to match on new annotations,
					when the next rule element matches and evaluates true on this
					annotation.

					Examples:
					<programlisting><![CDATA[
				Input:    123 456 small small Big 
				Rule:     W*? CW
				Matched:  small small Big
				Matched:  small Big
				Matched:  Big
				]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.quantifier.pg">
				<title>+ Plus Greedy</title>
				<para>
					The Plus Greedy quantifier needs to match on at least one
					annotation. Please mind, that a rule element after a rule element
					with a Plus Greedy quantifier matches and evaluates on different
					conditions.

					Examples:

					<programlisting><![CDATA[
				Input:    123 456 small small Big 
				Rule:     SW+ 
				Matched:  small small
				Matched:  small 
				]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.quantifier.pr">
				<title>+? Plus Reluctant</title>
				<para>
					The Plus Reluctant quantifier has to match on at least one
					annotation in order to evaluate true, but stops when the next rule
					element is able to match on this annotation.

					Examples:
					<programlisting><![CDATA[
				Input:    123 456 small small Big 
				Rule:     W+? CW
				Matched:  small small Big
				]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.quantifier.qg">
				<title>? Question Greedy</title>
				<para>
					The Question Greedy quantifier matches optionally on an annotation
					and therefore always evaluates true.

					Examples:
					<programlisting><![CDATA[
				Input:    123 456 small Big small Big 
				Rule:     SW CW? SW
				Matched:  small Big small
				]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.quantifier.qr">
				<title>?? Question Reluctant</title>
				<para>
					The Question Reluctant quantifier matches optionally on an
					annotation if the next rule element can not match on the same
					annotation and therefore always evaluates true.

					Examples:
					<programlisting><![CDATA[
				Input:    123 456 small Big small Big 
				Rule:     SW CW?? SW
				Matched:  small Big small
				]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.quantifier.mmg">
				<title>[x,y] Min Max Greedy</title>
				<para>
					The Min Max Greedy quantifier has to match at least x and at most y
					annotations of its rule element to elaluate true.

					Examples:
					<programlisting><![CDATA[
				Input:    123 456 small Big small Big 
				Rule:     SW CW[1,2] SW
				Matched:  small Big small
				]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.quantifier.mmr">
				<title>[x,y]? Min Max Reluctant</title>
				<para>
					The Min Max Greedy quantifier has to match at least x and at most y
					annotations of its rule element to elaluate true, but stops to
					match
					on additional annotations if the next rule element is able to
					match
					on this annotation.

					Examples:
					<programlisting><![CDATA[
				Input:    123 456 small Big Big Big small Big 
				Rule:     SW CW[2,100]? SW
				Matched:  small Big Big Big small
				]]></programlisting>
				</para>
			</section>
		</section>
		<section id="ugr.tools.tm.condition">
			<title>Conditions</title>
			<para>
			</para>
			<section id="ugr.tools.tm.condition.after">
				<title>AFTER</title>
				<para>

					The AFTER condition evaluates true, if an annotation of the given
					type preceeds the matched annotations.

					Definition
					<programlisting><![CDATA[AFTER(Type|TypeListExpression)  ]]></programlisting>

					Example

					<programlisting><![CDATA[CW{AFTER(SW)}; ]]></programlisting>
					Here, the rule matches on a capitalized word, if there is any small
					written word previously.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.and">
				<title>AND</title>
				<para>
					The AND Condition is a composed condition and evaluates true, if
					all
					contained conditions are evaluated true.

					Definition

					<programlisting><![CDATA[AND(Condition1,...,ConditionN)  ]]></programlisting>

					Example

					<programlisting><![CDATA[Paragraph{AND(PARTOF(Headline),CONTAINS(Keyword))->MARK(ImportantHeadline)}; ]]></programlisting>

					In this example a Paragraph is annotated with the ImportantHealine
					annotation, if it is a Headline and contains Keyword.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.before">
				<title>BEFORE</title>
				<para>

					The BEFORE condition evaluates true, if the matched annotations
					prceeds an annotation of the given type.

					Definition
					<programlisting><![CDATA[BEFORE (Type|TypeListExpression)  ]]></programlisting>

					Example

					<programlisting><![CDATA[CW{BEFORE(SW)}; ]]></programlisting>
					Here, the rule matches on a capitalized word, if there is any small
					written word afterwards.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.contains">
				<title>CONTAINS</title>
				<para>

					The CONTAINS condition evaluates true if the amount or percentage
					of
					certain types in the window of the matched annotation is in a
					predefined interval.

					Definition

					<programlisting><![CDATA[CONTAINS(Type(,NumbericalExpression,NumbericalExpression(,BooleanExpression)?)?) ]]></programlisting>

					Example

					<programlisting><![CDATA[Paragraph{CONTAINS(Keyword)->MARK(KeywordParagraph)}; ]]></programlisting>

					A Pararaph is annotated with a KeywordParagraph annotation, if it
					contains a Keyword annotation.

					<programlisting><![CDATA[Paragraph{CONTAINS(Keyword,2,4)->MARK(KeywordParagraph)}; ]]></programlisting>

					A Pararaph is annotated with a KeywordParagraph annotation, if it
					contains between two and four Keyword annotations.

					<programlisting><![CDATA[Paragraph{CONTAINS(Keyword,50,100,true)->MARK(KeywordParagraph)}; ]]></programlisting>

					A Pararaph is annotated with a KeywordParagraph annotation, if it
					contains between 50% and 100% Keyword annotations. This is
					calculated based on the tokens of the Paragraph. If the Paragraph
					contains six basic annatotions, two of them are part of one Keyword
					annotation and one basic annotation is also annotated with a
					Keyword
					annotation, then the percantage of the contained Keywords
					is
					50%.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.contextcount">
				<title>CONTEXTCOUNT</title>
				<para>

					The CONTEXTCOUNT condition counts the annotations of the matched
					type and stores the amount in a optional numerical variable.
					Additionally the condition evaluates true, if the amount is in a
					predefined interval.

					Definition

					<programlisting><![CDATA[CONTEXTCOUNT(Type(,NumbericalExpression,NumbericalExpression(,Variable)?)?) ]]></programlisting>

					Example

					<programlisting><![CDATA[Keyword{CONTEXTCOUNT(Paragraph,0,1000,var)->MARK(KeywordParagraph)}; ]]></programlisting>

					Here, the position in a Paragraph of the matched Keyword annotation
					is calculated and stored in the variable var.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.count">
				<title>COUNT</title>
				<para>

					The COUNT condition counts the annotations of a given type and
					stores the amount in a optional numerical variable. Additionally
					the
					condition evaluates true, if the amount is in a predefined
					interval.

					Definition

					<programlisting><![CDATA[COUNT(Type(,NumbericalExpression,NumbericalExpression)?(,NumberVariable)?) ]]></programlisting>
					<programlisting><![CDATA[COUNT(ListExpression(,NumbericalExpression,NumbericalExpression)?(,NumberVariable)?) ]]></programlisting>

					Example

					<programlisting><![CDATA[Paragraph{COUNT(Keyword,1,10,var)->MARK(KeywordParagraph)}; ]]></programlisting>

					Here, the amount of Keyword annotations in a Paragraph is
					calculated
					and stored in the variable var. The action of the rule
					will be
					executed if one to ten Keywords were counted.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.currentcount">
				<title>CURRENTCOUNT</title>
				<para>


					Definition

					<programlisting><![CDATA[CURRENTCOUNT(Type(,NumbericalExpression,NumbericalExpression(,Variable)?)?) ]]></programlisting>

					Example

				</para>
			</section>
			<section id="ugr.tools.tm.condition.endswith">
				<title>ENDSWITH</title>
				<para>

					The ENDSWITH condition evaluates true, if an annotation of the
					given
					type ends exactly at the same position as the matched
					annotation.

					Definition
					<programlisting><![CDATA[ENDSWITH(Type|TypeListExpression)  ]]></programlisting>

					Example

					<programlisting><![CDATA[Paragraph{ENDSWITH(SW)}; ]]></programlisting>
					Here, the rule matches on a Paragraph annotation, if it ends with
					small written word.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.feature">
				<title>FEATURE</title>
				<para>


					The FEATURE condition compares a feature of the matched annotation
					with the the second argument.

					Definition

					<programlisting><![CDATA[FEATURE(StringExpression,Expression) ]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{FEATURE("language",targetLanguage)}
]]></programlisting>
					Here, this rule matched, if the feature with the name "language" of
					the document annotation equals the value of the variable
					targetLanguage.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.if">
				<title>IF</title>
				<para>

					The IF evaluates true if the contained BooleanExpression does.

					Definition

					<programlisting><![CDATA[IF(BooleanExpression) ]]></programlisting>

					Example

					<programlisting><![CDATA[Paragraph{IF(keywordAmount > 5)->MARK(KeywordParagraph)}; ]]></programlisting>

					A Paragraph annotation is annotated with a KeywordParagraph
					annotation, if the value of the variable keywordAmount is greater
					than five.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.inlist">
				<title>INLIST</title>
				<para>

					The INLIST condition is fulfilled, if the matched annotation is
					listed in a given word list. The (relative) edit distance is
					currently disabled.

					Definition

					<programlisting><![CDATA[INLIST(WordList(,NumberExpression,(BooleanExpression)?)?) ]]></programlisting>
					<programlisting><![CDATA[INLIST(StringList(,NumberExpression,(BooleanExpression)?)?) ]]></programlisting>

					Example

					<programlisting><![CDATA[Keyword{INLIST(names.txt)->MARK(SpecialKeyword)}; ]]></programlisting>

					A Keyword is annotated with the type SpecialKeyword, if the text of
					the Keyword annotation is listed in the word list names.txt.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.is">
				<title>IS</title>
				<para>


					The IS conditions evaluates true, if there is an annotation of the
					given type with the same offsets as the matched annotations

					Definition


					<programlisting><![CDATA[IS(Type) ]]></programlisting>

					Example

				</para>
			</section>
			<section id="ugr.tools.tm.condition.isintag">
				<title>ISINTAG</title>
				<para>

					The ISINTAG condition evaluates true, if the matched annotation is
					in the given HTML tag. Attributes are currently disabled.

					Definition

					<programlisting><![CDATA[ISINTAG(StringExpression(,StringExpression '=' StringExpression)?) ]]></programlisting>

					Example

					<programlisting><![CDATA[Paragraph{ISINTAG("h1")->MARK(Headline)}; ]]></programlisting>

					A Paragraph is marked as a Headline, if the matched text is in a h1
					HTML tag.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.last">
				<title>LAST</title>
				<para>

					The LAST condition evaluates true, if the type of the last token of
					the matched annotation is subsumed by the given type.

					Definition

					<programlisting><![CDATA[LAST(TypeExpression) ]]></programlisting>

					Example

					<programlisting><![CDATA[Document{LAST(CW)}; ]]></programlisting>

					This rule fires, if the last token of the document is a capitalized
					word.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.mofn">
				<title>MOFN</title>
				<para>

					The MOFN condition is a composed condition and evaluates true, if
					the amount of conditions that evaluated true is in a given
					interval.

					Definition

					<programlisting><![CDATA[MOFN(NumberExpression,NumberExpression(Condition1,...,ConditionN)) ]]></programlisting>

					Example

					<programlisting><![CDATA[Paragraph{MOFN(1,1(PARTOF(Headline),CONTAINS(Keyword))->MARK(HeadlineXORKeywords)}; ]]></programlisting>

					A Paragraph is marked as a HeadlineXORKeywords, if the matched text
					is either part of a Headline annotation or contains Keyword
					annotations.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.near">
				<title>NEAR</title>
				<para>

					The NEAR condition is fullfilled, if the distance (min/max) of the
					matched annotation to a given type is smaller than a given
					NumberExpression. The direction is defined by a parameter. This
					condition works currently on a unfiltered index.

					Definition

					<programlisting><![CDATA[NEAR(TypeExpression,NumberExpression,NumberExpression(,BooleanExpression)?) ]]></programlisting>

					Example

					<programlisting><![CDATA[Paragraph{NEAR(Headline,0,10,false)->MARK(NoHeadline)}; ]]></programlisting>

					A Paragraph that starts at most ten tokens after a headline, is
					annotated with the NoHeadline annotation.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.not">
				<title>NOT</title>
				<para>

					The NOT condition negates the result of its contained condition.

					Definition

					<programlisting><![CDATA["-"Condition ]]></programlisting>

					Example

					<programlisting><![CDATA[Paragraph{-PARTOF(Headline)->MARK(Headline)}; ]]></programlisting>

					A Paragraph that is not part of an Headline annotation yet is
					annotated with a Headline annotation.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.or">
				<title>OR</title>
				<para>

					The OR Condition is a composed condition and evaluates true, if one
					contained condition is evaluated true.

					Definition

					<programlisting><![CDATA[
OR(Condition1,...,ConditionN)
]]></programlisting>


					Example

					<programlisting><![CDATA[
Paragraph{OR(PARTOF(Headline),CONTAINS(Keyword))->MARK(ImportantParagraph)};
]]></programlisting>

					In this example a Paragraph is annotated with the
					ImportantParagraph
					annotation, if it is a Headline or contains
					Keyword.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.parse">
				<title>PARSE</title>
				<para>

					The PARSE condition is fulfilled, if the covered text of the
					matched
					annotation can be transformed in a value of the given
					variable.

					Definition

					<programlisting><![CDATA[PARSE(variable) ]]></programlisting>

					Example

					<programlisting><![CDATA[NUM{PARSE(var)}; ]]></programlisting>
					Here, a number is stored in a numerical variable.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.partof">
				<title>PARTOF</title>
				<para>
					The PARTOF condition is fulfilled, if the matched annotation is
					part
					of an annotation of a given type. However this condition is
					also
					fulfilled if the matched type is subsumed or an anchor of the
					given
					type. Use the (much slower) PARTOFNEQ condition instead if
					needed.

					Definition

					<programlisting><![CDATA[PARTOF(Type|TypeListExpression) ]]></programlisting>

					Example

					<programlisting><![CDATA[Paragraph{PARTOF(Headline) -> MARK(ImportantParagraph)}; ]]></programlisting>

					A Paragraph is an ImportantParagraph if the matched text is part of
					a headline.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.partofneq">
				<title>PARTOFNEQ</title>
				<para>
					The PARTOF condition is fulfilled, if the matched annotation is
					part
					of (smaller than and inside of) an annotation of a given type.

					Definition

					<programlisting><![CDATA[PARTOFNEQ(Type|TypeListExpression) ]]></programlisting>

					Example

					<programlisting><![CDATA[W{PARTOFNEQ(Headline) -> MARK(ImportantWord)}; ]]></programlisting>

					A word is an ImportantWord if it is part of a headline.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.position">
				<title>POSITION</title>
				<para>

					The POSITION counts the annotations of the type of the matched
					annotation. The condition is fulfilled if the index equals the
					value
					of a given NumericalExpression.

					Definition

					<programlisting><![CDATA[POSITION(Type,NumberExpression(,Variable)?) ]]></programlisting>

					Example

					<programlisting><![CDATA[Keyword{POSITION(Paragraph,2)->MARK(SecondKeyword)}; ]]></programlisting>

					The second Keyword in a Paragraph is annotated with the type
					SecondKeyword.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.regexp">
				<title>REGEXP</title>
				<para>

					The REGEXP condition is fullfilled, if the given pattern macthes on
					the matched annotation. Quotes are currently forbidden in a pattern

					Definition

					<programlisting><![CDATA[REGEXP(StringExpression) ]]></programlisting>

					Example

					<programlisting><![CDATA[Keyword{REGEXP("..")->MARK(SmallKeyword)}; ]]></programlisting>

					A Keyword that only consists of the chars is annotated with a
					SmallKeyword annotation.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.score">
				<title>SCORE</title>
				<para>

					The SCORE condition evaluates the value of the heuristic score of
					the matched annotation. The condition is fulfilled if the value is
					in a given interval. Optionally the amount can be stored in a
					variable.

					Definition

					<programlisting><![CDATA[SCORE(NumberExpression,NumberExpression(,Variable)?) ]]></programlisting>

					Example

					<programlisting><![CDATA[MaybeHeadline{SCORE(40,100)->MARK(Headline)}; ]]></programlisting>

					A annotation of the type MaybeHeadline is annotated with Headline,
					if its score is between 40 and 100.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.size">
				<title>SIZE</title>
				<para>

					This contition counts the amount of elements of the given list.

					Definition

					<programlisting><![CDATA[SIZE(ListExpression(,NumberExpression,NumberExpression)(,Variable)?) ]]></programlisting>

					Example

					<programlisting><![CDATA[Document{SIZE(list,4,10,var)}; ]]></programlisting>

					This rule fires, if the given list contains between 4 and 10
					elements. Additionally, the exact amount is stored in the variable
					var.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.startswith">
				<title>STARTSWITH</title>
				<para>


					The STARTSWITH condition evaluates true, if an annotation of the
					given type starts exactly at the same position as the matched
					annotation.

					Definition
					<programlisting><![CDATA[STARTSWITH(Type|TypeListExpression)  ]]></programlisting>

					Example

					<programlisting><![CDATA[Paragraph{STARTSWITH(SW)}; ]]></programlisting>
					Here, the rule matches on a Paragraph annotation, if it starts with
					small written word.

				</para>
			</section>
			<section id="ugr.tools.tm.condition.totalcount">
				<title>TOTALCOUNT</title>
				<para>

					Definition

					<programlisting><![CDATA[TOTALCOUNT(Type(,NumbericalExpression,NumbericalExpression(,Variable)?)?) ]]></programlisting>

					Example

				</para>
			</section>
			<section id="ugr.tools.tm.condition.vote">
				<title>VOTE</title>
				<para>

					The VOTE condition counts the annotations of the given types and
					evaluates true, if it found more annotations of the first type.

					Definition

					<programlisting><![CDATA[VOTE(TypeExpression,TypeExpression) ]]></programlisting>

					Example

					<programlisting><![CDATA[
Paragraph{VOTE(FirstName,LastName)};
]]></programlisting>
					Here, this rule fires, if a paragraph contains more firstnames than
					lastnames.

				</para>
			</section>
		</section>
		<section id="ugr.tools.tm.action">
			<title>Actions</title>
			<para>
			</para>
			<section id="ugr.tools.tm.action.add">
				<title>AFTER</title>
				<para>



					This action adds lists or single values to a given list

					Definition

					<programlisting><![CDATA[
ADD(ListVariable,(Argument)+)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->ADD(list, var)};
]]></programlisting>


					In this example, the variable "var" is added to the list "list".

				</para>
			</section>
			<section id="ugr.tools.tm.action.assign">
				<title>ASSIGN</title>
				<para>


					This action assigns a numerical value to a numerical variable.

					Definition

					<programlisting><![CDATA[
ASSIGN(Variable,NumericalExpression)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->ASSIGN(amount, (amount/2))};
]]></programlisting>


					In this example, the value of the variable amount is halved.

				</para>
			</section>
			<section id="ugr.tools.tm.action.call">
				<title>CALL</title>
				<para>

					The CALL action initiates the execution of a different script file
					or script block. Currently only complete script files are
					supported.

					Definition
					<programlisting><![CDATA[
CALL(DifferentFile)
]]></programlisting>

					Example
					<programlisting><![CDATA[
Document{->CALL(NamedEntities)};
]]></programlisting>
					Here, a script for named entity recognition is executed.

				</para>
			</section>
			<section id="ugr.tools.tm.action.clear">
				<title>CLEAR</title>
				<para>


					This action removes all elements of the given list.

					Definition

					<programlisting><![CDATA[
CLEAR(ListVariable)
]]></programlisting>

					Example

					<programlisting><![CDATA[ 
Document{-> CLEAR(SomeList)};
]]></programlisting>
					This rule clears the list SomeList.
				</para>
			</section>
			<section id="ugr.tools.tm.action.color">
				<title>COLOR</title>
				<para>

					The COLOR action set the color of a annotation type in the modified
					view if the rule is fired. The supported colors are: black, silver,
					gray, white, maroon, red, purple, fuchsia, green, lime, olive,
					yellow, navy, blue, aqua, lightblue, lightgreen, orange, pink,
					salmon, cyan, violet, tan, brown, white, mediumpurple.

					Definition

					<programlisting><![CDATA[
COLOR(TypeExpression,StringExpression(, StringExpression(, BooleanExpression)?)?)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->COLOR(Headline,"red", "black", true)};
]]></programlisting>
					This rule colors all Headline in the modified view.
				</para>
			</section>
			<section id="ugr.tools.tm.action.create">
				<title>CREATE</title>
				<para>

					This action creates a complex structure, a annotation with
					features.

					Definition

					<programlisting><![CDATA[
CREATE(TypeExpression(,NumberExpression)*(,StringExpression = Expression)+)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Paragraph{COUNT(ANY,0,10000,variable)->CREATE(Headline,"size" = variable)};
]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.action.del">
				<title>DEL</title>
				<para>


					The DEL action deletes the matched text fragments in the modified
					view.

					Definition

					<programlisting><![CDATA[
DEL
]]></programlisting>

					Example

					<programlisting><![CDATA[
Name{->DEL};
]]></programlisting>
					This rule deletes all text fragments that are annotated with a Name
					annotation.

				</para>
			</section>
			<section id="ugr.tools.tm.action.exec">
				<title>EXEC</title>
				<para>


					The EXEC action initiates the execution of a different script file
					or analysis engine on the complete input document.

					Definition
					<programlisting><![CDATA[
EXEC(DifferentFile)
]]></programlisting>

					Example
					<programlisting><![CDATA[
ENGINE NamedEntities;
Document{->EXEC(NamedEntities)};
]]></programlisting>
					Here, an analysis engine for named entity recognition is executed
					once on the complete document independent of the matched text and
					the current filtering settings. If the argument refers to another
					script file, then then a new view on the document is created: the
					complete text of the original CAS and with the default filtering
					settings of the TextMarker analysis engine.

				</para>
			</section>
			<section id="ugr.tools.tm.action.fill">
				<title>FILL</title>
				<para>

					This action fills a complex structure, an annotation of the given
					type with feature values.

					Definition

					<programlisting><![CDATA[
FILL(TypeExpression(,StringExpression = Expression)+)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Headline{COUNT(ANY,0,10000,variable)->FILL(Headline,"size" = variable)};
]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.action.filtermarkup">
				<title>FILTERMARKUP</title>
				<para>
					This action filters the given types of markup. They are now ignored
					by rules.

					Definition

					<programlisting><![CDATA[
FILTERMARKUP((StringExpression(,StringExpression)*))?
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->FILTERMARKUP(br)};
]]></programlisting>

					This rule filters all markup in the input document.

				</para>
			</section>
			<section id="ugr.tools.tm.action.filtertype">
				<title>FILTERTYPE</title>
				<para>


					This action filters the given types of annotation. They are now
					ignored by rules. Expressions are not yet supported.

					Definition

					<programlisting><![CDATA[
FILTERTYPE((TypeExpression(,TypeExpression)*))?
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->FILTERTYPE(SW)};
]]></programlisting>

					This rule filters all small written words in the input document.
				</para>
			</section>
			<section id="ugr.tools.tm.action.gather">
				<title>GATHER</title>
				<para>

					This action creates a complex structure, a annotation with
					features.
					The features are collected using the given indexes of the
					rule
					elements of the complete rule.

					Definition

					<programlisting><![CDATA[
GATHER(TypeExpression(,NumberExpression)*(,StringExpression = NumberExpression)+)
]]></programlisting>

					Example

					<programlisting><![CDATA[
A B C{-> GATHER(FS, "a" = 1, "b" = 2)};
]]></programlisting>
					This rule creates a Feature Structure FS and assigns the annotation
					A (matched by the first rule element) and the annotation B (matched
					by the second rule element) the the features "a" and "b" of that
					feature structure.

				</para>
			</section>
			<section id="ugr.tools.tm.action.get">
				<title>GET</title>
				<para>

					This action retrieves an element of the given list dependent on a
					given strategy.

					Definition

					<programlisting><![CDATA[
GET(ListExpression, Variable, StringExpression)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->GET(list, var, "dominant")};
]]></programlisting>

					In this example, the element of the list that occurs most is stored
					in the variable "var".
				</para>
			</section>
			<section id="ugr.tools.tm.action.getfeature">
				<title>GETFEATURE</title>
				<para>


					This action stores the value of the given feature of the matched
					annotation type in the given variable.

					Definition

					<programlisting><![CDATA[
GETFEATURE(StringExpression, Variable)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->GETFEATURE("language", stringVar)};
]]></programlisting>

					In this example, variable "stringVar" will contain the value of the
					feature "language".
				</para>
			</section>
			<section id="ugr.tools.tm.action.getlist">
				<title>GETLIST</title>
				<para>

					This action retrieves a list of elements dependent on a given
					strategy.

					Definition

					<programlisting><![CDATA[
GETLIST(ListVariable, StringExpression)
]]></programlisting>

					Example


				</para>
			</section>
			<section id="ugr.tools.tm.action.log">
				<title>LOG</title>
				<para>

					The LOG action simply writes a log message

					Definition

					<programlisting><![CDATA[
LOG(StringExpression)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->LOG("processed")};
]]></programlisting>

					This rule writes a log message with the string "processed".

				</para>
			</section>
			<section id="ugr.tools.tm.action.mark">
				<title>MARK</title>
				<para>

					The MARK action is the most important action in the TextMarker
					system. This action creates a new annotation dependent on the text
					fragments or annotations matched by the rule. The indexes can be
					used to create an annotation the spanns the matched information of
					several rule elements.

					Definition

					<programlisting><![CDATA[
MARK(TypeExpression(,NumericalExpression)*)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Freeline Paragraph{->MARK(ParagraphAfterFreeline,1,2)};
]]></programlisting>

					This rule matches on a free line followed by a paragraph and
					annotates both in a single ParagraphAfterFreeline annotation. The
					two numberical expressions at the end of the mark action indicate
					that the matched text of the first and the second rule elements are
					joined to create the boundaries of the new annotation.

				</para>
			</section>
			<section id="ugr.tools.tm.action.markonce">
				<title>MARK</title>
				<para>


					This action has the same functionality as MARK, but creates a
					new
					annotation only if it does not yet exist.

				</para>
			</section>
			<section id="ugr.tools.tm.action.markfast">
				<title>MARKFAST</title>
				<para>

					The MARKFAST action uses an external ressource to annotate the
					content of the matched annotation more efficiently. It provides
					options for "ignoreCase" and an amount of characters for the
					threshold.

					Definition

					<programlisting><![CDATA[
MARKFAST(TypeExpression,ListExpression(,BooleanExpression(,NumberExpression)?)?)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->MARKFAST(FirstName,'firstnames.txt',true,2)};
]]></programlisting>

					This rule annotates all first names in the document and ignore the
					case if the length of the word is greater than 2.

				</para>
			</section>
			<section id="ugr.tools.tm.action.marklast">
				<title>MARKLAST</title>
				<para>

					The MARKLAST action annotates the last token of the matched
					annotation with the given type.

					Definition

					<programlisting><![CDATA[
MARKLAST(TypeExpression)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->MARKLAST(Last)};
]]></programlisting>

					This rule annotates the last token of the document.

				</para>
			</section>
			<section id="ugr.tools.tm.action.markscore">
				<title>MARKSCORE</title>
				<para>

					The MARKSCORE action is provides the same functionality as the MARK
					action. Furthermore heuristic scores are supported.

					Definition

					<programlisting><![CDATA[
MARKSCORE(NumberExpression,TypeExpression(,NumericalExpression)*)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Freeline Paragraph{->MARKSCORE(10,ParagraphAfterFreeline,1,2)};
]]></programlisting>

					This rule matches on a free line followed by a paragraph and
					annotates both in a single ParagraphAfterFreeline annotation. The
					two numberical expressions at the end of the mark action indicate
					that the matched text of the first and the second rule elements are
					joined to create the boundaries of the new annotation.
					Additionally,
					the score "10" is added to the heuristic threshold of
					this
					annotation.

				</para>
			</section>
			<section id="ugr.tools.tm.action.marktable">
				<title>MARKTABLE</title>
				<para>

					The MARKTABLE action creates possibly new complex annoattions and
					is
					able to assign entries of the given table to its features.

					Definition

					<programlisting><![CDATA[
MARKTABLE(TypeExpression, NumberExpression, TableExpression, (,StringExpression = NumberExpression)+)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{-> MARKTABLE(Struct, 1, TestTable, "first" = 2)};
]]></programlisting>

					In this example, the document is searched for all occurences of the
					entries of the first column of the given table, an annotation of
					the
					type Struct is created and its feature "first" is filled with
					the
					entry of the second column.

				</para>
			</section>
			<section id="ugr.tools.tm.action.merge">
				<title>MERGE</title>
				<para>

					This action merges the given lists. The first parameter defines if
					it is an intersection or union. The second parameter is the list
					variable that will contain the result.

					Definition

					<programlisting><![CDATA[
MERGE(BooleanExpression, ListVariable, ListExpression, (ListExpression)+)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->MERGE(false, listVar, list1, list2, list3)};
]]></programlisting>

					The elements that occur in all three lists will be placed in the
					list listVar.
				</para>
			</section>
			<section id="ugr.tools.tm.action.matchedtext">
				<title>MATCHEDTEXT</title>
				<para>


					Definition

					<programlisting><![CDATA[
MATCHEDTEXT(StringVariable(,NumericalExpression)*)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Paragraph{->MATCHEDTEXT(StringVariable)};
]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.action.remove">
				<title>REMOVE</title>
				<para>


					This action removes lists or single values from a given list

					Definition

					<programlisting><![CDATA[
REMOVE(ListVariable,(Argument)+)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->REMOVE(list, var)};
]]></programlisting>


					In this example, the variable "var" is removed from the list
					"list".
				</para>
			</section>
			<section id="ugr.tools.tm.action.removeduplicate">
				<title>REMOVEDUPLICATE</title>
				<para>


					This action removes all duplicates of a given list

					Definition

					<programlisting><![CDATA[
REMOVEDUPLICATE(ListVariable)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->REMOVEDUPLICATE(list)};
]]></programlisting>

				</para>
			</section>
			<section id="ugr.tools.tm.action.replace">
				<title>REPLACE</title>
				<para>

					The REPLACE action remembers the modification for the matched
					annotation.

					Definition

					<programlisting><![CDATA[
REPLACE(StringExpression)
]]></programlisting>

					Example

					<programlisting><![CDATA[
FirstName{->REPLACE("first name")};
]]></programlisting>


					This rule replaces all first names with the string "first name".

				</para>
			</section>
			<section id="ugr.tools.tm.action.retainmarkup">
				<title>RETAINMARKUP</title>
				<para>

					This action retains the given types of markup. They are now not
					ignored by rules.

					Definition

					<programlisting><![CDATA[
RETAINMARKUP((StringExpression(,StringExpression)*))?
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->RETAINMARKUP("img")};
]]></programlisting>

					All &lt;img&gt; markup elements are retained and can be macthed by
					rules.

				</para>
			</section>
			<section id="ugr.tools.tm.action.retaintype">
				<title>RETAINTYPE</title>
				<para>

					This action retains the given types. They are now not ignored by
					rules.

					Definition

					<programlisting><![CDATA[
RETAINTYPE((TypeExpression(,TypeExpression)*))?
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->RETAINTYPE(SPACE)};
]]></programlisting>

					All spaces are retained and can be macthed by rules.

				</para>
			</section>
			<section id="ugr.tools.tm.action.setfeature">
				<title>SETFEATURE</title>
				<para>

					This action sets the value of a feature of the matched complex
					structure or annotation.

					Definition

					<programlisting><![CDATA[
SETFEATURE(StringExpression,Expression)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->SETFEATURE("language","en")};
]]></programlisting>
					Here, the language of the input document is set to english.

				</para>
			</section>
			<section id="ugr.tools.tm.action.transfer">
				<title>TRANSFER</title>
				<para>

					This action creates a new feature structure and adds all compatible
					features of the matched annotation.

					Definition

					<programlisting><![CDATA[
TRANSFER(TypeExpression)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->TRANSFER(LanguageStorage)};
]]></programlisting>
					Here, a new feature structure "LanguageStorage" is created and the
					features of the DocumentAnnotation are copied. E.g., if
					LanguageStorage defined a feature named "language", then the
					feature
					value of the DocumentAnnotation is copied.

				</para>
			</section>
			<section id="ugr.tools.tm.action.trie">
				<title>TRIE</title>
				<para>


					This action uses an external multi tree word list to annotated the
					matched annotation and provides several configuration paramters.

					Definition

					<programlisting><![CDATA[
TRIE((String = Type)+,ListExpression,Boolean,Number,Boolean,Number,String)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Document{->TRIE("FirstNames.txt" = FirstName, "Companies.txt" = Company, 'Dictionary.mtwl', true, 4, false, 0, ".,-/ ")};
]]></programlisting>

					Here, the Dictionary.mtwl that contains word lists for first names
					and companies is used to annotate the document. The words
					previously
					contained in the FirstNames.txt are annotated with the
					type
					FirstName and the word in the Companies.txt with the type
					Company.
					The case of the word is ignored if the length of the word
					exceeds 4.
					The edit distance is deactivated. The cost of an edit
					operation can
					currently not be configured by an argument. The last
					argument
					additionally defines several chars that will be ignored.

				</para>
			</section>
			<section id="ugr.tools.tm.action.unmark">
				<title>UNMARK</title>
				<para>

					This action removes the annotation of the given type overlapping
					the
					matched text.

					Definition

					<programlisting><![CDATA[
UNMARK(TypeExpression)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Headline{->UNMARK(Headline)};
]]></programlisting>
					Here, the headline annotation is removed.


				</para>
			</section>
			<section id="ugr.tools.tm.action.unmarkall">
				<title>UNMARKALL</title>
				<para>

					This action removes the annotation of the given type and all of its
					descendants overlapping the matched text.

					Definition

					<programlisting><![CDATA[
UNMARKALL(TypeExpression, TypeListExpression)
]]></programlisting>

					Example

					<programlisting><![CDATA[
Annotation{->UNMARKALL(Annotation, {Headline})};
]]></programlisting>
					Here, all annotations but headlines are removed.
				</para>
			</section>
		</section>
		<section id="ugr.tools.tm.expressions">
			<title>Expressions</title>
			<para>
			</para>
			<section id="ugr.tools.tm.expressions.type">
				<title>Type Expressions</title>
				<para>
				</para>
			</section>
			<section id="ugr.tools.tm.expressions.numer">
				<title>Number Expressions</title>
				<para>
				</para>
			</section>
			<section id="ugr.tools.tm.expressions.string">
				<title>String Expressions</title>
				<para>
				</para>
			</section>
			<section id="ugr.tools.tm.expressions.boolean">
				<title>Boolean Expressions</title>
				<para>
				</para>
			</section>
		</section>
		<section id="ugr.tools.tm.filtering">
			<title>Robust extraction using filtering</title>
			<para>
				Rule based or pattern based information extraction systems often
				suffer from unimportant fill words, additional whitespace and
				unexpected markup. The TextMarker System enables the knowledge
				engineer to filter and to hide all possible combinations of
				predefined and new types of annotations. Additionally, it can
				differentiate between every kind of HTML markup and XML tags. The
				visibility of tokens and annotations is modified by the actions of
				rule elements and can be conditioned using the complete
				expressiveness of the language. Therefore the TextMarker system
				supports a robust approach to information extraction and simplifies
				the creation of new rules since the knowledge engineer can focus on
				important textual features. If no rule action changed the
				configuration of the filtering settings, then the default filtering
				configuration ignores whitespaces and markup. Using the default
				setting, the following rule matches all four types of input in this
				example:
				<programlisting><![CDATA[
"Dr" PERIOD CW CW
]]></programlisting>
				<programlisting><![CDATA[
Dr. Peter Steinmetz
Dr . Peter      Steinmetz
Dr. <b><i>Peter</i> Steinmetz</b>
Dr.PeterSteinmetz
]]></programlisting>
			</para>
		</section>
		<section id="ugr.tools.tm.blocks">
			<title>Blocks</title>
			<para>
				Blocks combine some more complex control structures in the
				TextMarker
				language: conditioned statement, loops and procedures.


				The
				rule
				element in the definition of a block has to define a
				condition/action
				part, even if that part is empty (LCURLY and
				RCULRY).


				A block can use
				normal conditions to condition the execution
				of its
				containing rules.

				Examples:

				<programlisting><![CDATA[
DECLARE Month;

BLOCK(EnglishDates) Document{FEATURE("language", "en")} {
    Document{->MARKFAST(Month,'englishMonthNames.txt')};
    //...
}

BLOCK(GermanDates) Document{FEATURE("language", "de")} {
    Document{->MARKFAST(Month,'germanMonthNames.txt')};
    //...
}
]]></programlisting>


				A block can be used to execute the containing rule on a sequence of
				similar text passages.

				Examples:
				<programlisting><![CDATA[
BLOCK(Paragraphs) Paragraphs{} { // <- limit the local view on the document: defines a local document
    // This rule will be executed for each Paragraph that can be found in the current document.
    Document{CONTAINS(Keyword)->MARK(SpecialParagraph)}; 
    // Here, Document represents not the complete input document, but each Paragraph defined by the block statement.
}
]]></programlisting>
			</para>
		</section>
		<section id="ugr.tools.tm.score">
			<title>Heuristic extraction using scoring rules</title>
			<para>
				Diagnostic scores are a well known and successfully applied
				knowledge
				formalization pattern for diagnostic problems. Single known
				findings
				valuate a possible solution by adding or subtracting points
				on an
				account of that solution. If the sum exceeds a given threshold,
				then
				the solution is derived. One of the advantages of this pattern
				is the
				robustness against missing or false findings, since a high
				number of
				findings is used to derive a solution.

				The TextMarker system
				tries to transfer this diagnostic problem
				solution
				strategy to the
				information extraction problem. In addition to a
				normal creation of a
				new annotation, a MARK action can add positive
				or negative scoring
				points to the text fragments matched by the rule
				elements. If the
				amount of points exceeds the defined threshold for
				the respective
				type, then a new annotation will be created. Further,
				the current
				value of heuristic points of a possible annotation can
				be
				evaluated by
				the SCORE condition. In the following, the heuristic
				extraction using
				scoring rules is demonstrated by a short example:

				<programlisting><![CDATA[
			Paragraph{CONTAINS(W,1,5)->MARKSCORE(5,Headline)};
			Paragraph{CONTAINS(W,6,10)->MARKSCORE(2,Headline)};
			Paragraph{CONTAINS(Emph,80,100,true)->MARKSCORE(7,Headline)};
			Paragraph{CONTAINS(Emph,30,80,true)->MARKSCORE(3,Headline)};
			Paragraph{CONTAINS(CW,50,100,true)->MARKSCORE(7,Headline)};
			Paragraph{CONTAINS(W,0,0)->MARKSCORE(-50,Headline)};
			Headline{SCORE(10)->MARK(Realhl)};
			Headline{SCORE(5,10)->LOG("Maybe a headline")};
				]]></programlisting>


				In the first part of this rule set, annotations of the type
				paragraph
				receive scoring points for a headline annotation, if they
				fulfill
				certain CONTAINS conditions. The first condition, for
				example,
				evaluates to true, if the paragraph contains one word up to
				five
				words, whereas the fourth conditions is fulfilled, if the
				paragraph
				contains thirty up to eighty percent of emph annotations.
				The last
				two rules finally execute their actions, if the score of a
				headline
				annotation exceeds ten points, or lies in the interval of
				five and
				ten points, respectively.
			</para>
		</section>
		<section id="ugr.tools.tm.modification">
			<title>Modification</title>
			<para>
				There are different actions that can modify the input document,
				like DEL,
				COLOR and REPLACE. But the input document itself can not be
				modified
				directly. A seperate engine, the Modifier.xml, has to be
				called in
				order to create another cas view with the name "modified".
				In that
				document all modifications are executed.
			</para>
		</section>
	</section>
	<section id="ugr.tools.tm.workbench">
		<title>TextMarker Workbench</title>
		<para>
		</para>

		<section id="ugr.tools.tm.install">
			<title>Installation</title>
			<para>
				# Download, install and start an Eclipse 3.5 or Eclipse
				3.6.
				#
				Add the Apache UIMA update site
				(http://www.apache.org/dist/uima/eclipse-update-site/) and the
				TextMarker update site
				(http://ki.informatik.uni-wuerzburg.de/~pkluegl/updatesite/) to the
				available software sites in your Eclipse installation. This can be
				achived in the "Install New Software" dialog in the help menu of
				Eclipse.
				# Eclipse 3.6: TextMarker is currently based on DLTK
				1.0.
				Therefore, adding the DLTK 1.0 update site
				(http://download.eclipse.org/technology/dltk/updates-dev/1.0/) is
				required since the Eclipse 3.6 update site only supports DLTK 2.0.
				#
				Select "Install New Software" in the help menu of Eclipse, if not
				done yet.
				# Select the TextMarker update site at "Work with",
				deselect "Group
				items by category" and select "Contact all update
				sites during
				install to find required software"
				# Select the
				TextMarker feature and continue the dialog. The CEV
				feature is
				already contained in the TextMarker feature. Eclipse will
				automatically install the Apache UIMA (version 2.3) plugins and the
				DLTK Core Framework (version 1.X) plugins.
				# ''(OPTIONAL)'' If
				additional HTML visualizations are desired, then
				also install the CEV
				HTML feature. However, you need to install the
				XPCom and XULRunner
				features previously, for example by using an
				appropriate update site
				(http://ftp.mozilla.org/pub/mozilla.org/xulrunner/eclipse/). Please
				refer to the [CEV installation instruction|CEVInstall] for details.
				# After the successful installation, switch to the TextMarker
				perspective.

				You can also download the TextMarker plugins from
				[SourceForge.net|https://sourceforge.net/projects/textmarker/] and
				install the plugins mentioned above manually.
			</para>
		</section>
		<section id="ugr.tools.tm.project">
			<title>TextMarker Projects</title>
			<para>
				Similar to Java projects in Eclipse, the TextMarker workbench
				provides the possibility to create TextMarker projects. TextMarker
				projects require a certain folder structure that is created with the
				project. The most important folders are the script folder that
				contains the TextMarker rule files in a package and the descriptor
				folder that contains the generated UIMA components. The input folder
				contains the text files or xmiCAS files that will be executed when
				starting a TextMarker script. The result will be placed in the
				output folder.

				<programlisting><![CDATA[
		||Project element|| Used for
		| Project                   | the TextMarker project
		| - script                  | source folder with TextMarker scripts
		| -- my.package                 | the package, resulting in several folders 
		| --- Script.tm                 | a TextMarker script
		| - descriptor              | build folder for UIMA components
		| -- my/package                 | the folder structure for the components
		| --- ScriptEngine.xml          | the analysis engine of the Script.tm script
		| --- ScriptTypeSystem.xml      | the type system of the Script.tm script
		| -- BasicEngine.xml            | the analysis engine template for all generated engines in this project 
		| -- BasicTypeSystem.xml        | the type system template for all generated type systems in this project
		| -- InternalTypeSystem.xml     | a type system with TextMarker types
		| -- Modifier.xml               | the analysis engine of the optional modifier that creates the ''modified'' view
		| - input                   | folder that contains the files that will be processed when launching a TextMarker script
		| -- test.html                  | an input file containing html
		| -- test.xmi                   | an input file containing text and annotations
		| - output                  | folder that contains the files that were processed by a TextMarker script
		| -- test.html.modified.html    | the result of the modifier: replaced text and colored html
		| -- test.html.xmi              | the result CAS with optional information
		| -- test.xmi.modified.html     | the result of the modifier: replaced text and colored html
		| -- test.xmi.xmi               | the result CAS with optional information
		| - resources               | default folder for word lists and dictionaries
		| -- Dictionary.mtwl            | a dictionary in the "multi tree word list" format
		| -- FirstNames.txt             | a simple word list with first names:  one first name per line
		| - test                    | test-driven development is still under construction
   ]]></programlisting>

			</para>

		</section>
		<section id="ugr.tools.tm.explain">
			<title>Explanation</title>
			<para>
				Handcrafting rules is laborious, especially if the newly
				written rules do not
				behave as expected. The TextMarker System is
				able to protocol the
				application of each single rule and block in
				order to provide an
				explanation of the rule inference and a minmal
				debug functionality.

				The explanation component is built upon the CEV
				plugin. The
				information about the application of the rules itself is
				stored in
				the result xmiCAS, if the parameter of the executed engine
				are
				configured correctly. The simplest way the generate these
				information is to open a TextMarker file and click on the common
				"Debug" button (looks like a green bug) in your eclipse. The current
				TextMarker file will then be executed on the text files in the input
				directory and xmiCAS are created in the output directory containing
				the additional UIMA feature structures describing the rule
				inference. The resulting xmiCAS needs to be opened with the CEV
				plugin. However, only additional views are capable of displaying the
				debug information. In order to open the neccessary views, you can
				either open the "Explain" perspective or open the views separately
				and arrange them as you like.

				There are currently seven views that
				display information about the
				execution of the rules: Applied Rules,
				Selected Rules, Rule List,
				Matched Rules, Failed Rules, Rule Elements
				and Basic Stream.

			</para>

		</section>
		<section id="ugr.tools.tm.dictionaries">
			<title>Dictionariers</title>
			<para>

				The TextMarker system suports currently the usage of dictionaries in
				four different ways. The files are always encoded with UTF-8. The
				generated analysis engines provide a parameter "resourceLocation"
				that specifies the folder that contains the external dictionary
				files. The paramter is initially set to the resource folder of the
				current TextMarker project. In order to use a different folder,
				change for example set value of the paramter and rebuild all
				TextMarker rule files in the project in order to update all analysis
				engines.

				The algorithm for the detection of the entires of a
				dictionary:

				<programlisting><![CDATA[
for all basic annotations of the matched annotation do
  set current candidate to current basic
  loop
    if the dictionary contains current candidate then
      remember candidate
    else if an entry of the dictionary starts with the current candidate then
      add next basic annotation to the current candidate
      continue loop
    else
      stop loop
]]></programlisting>




				Word List (.txt)
				Word lists are simple text files that contain a term
				or string in each
				line. The strings may include white spaces and are
				sperated by a
				line break.

				Usage:
				Content of a file named FirstNames.txt
				(located in the resource folder of a
				TextMarker project):
				<programlisting><![CDATA[
Peter
Jochen
Joachim
Martin
]]></programlisting>

				Examplary rules:
				<programlisting><![CDATA[
LIST FirstNameList = 'FirstNames.txt';
DECLARE FirstName;
Document{-> MARKFAST(FirstName, FirstNameList)};
]]></programlisting>

				In this example, all first names in the given text file are
				annotated in the input document with the type FirstName.

				Tree Word
				List (.twl)
				A tree word list is a compiled word list similar to a
				trie. A .twl
				file is an XML-file that contains a tree-like structure
				with a node
				for each character. The nodes themselves refer to child
				nodes that
				represent all characters that succeed the caracter of the
				parent
				node. For single word entries, this is resulting in a
				complexity of
				O(m*log(n)) instead of a complexity of O(m*n) (simple
				.txt file),
				whereas m is the amount of basic annotations in the
				document and n
				is the amount of entries in the dictionary.

				Usage:
				A
				.twl file are generated using the popup menu. Select one or more
				.txt files (or a folder containing .txt files), click the right
				mouse button and choose ''Convert to TWL''. Then, one or more .twl
				files are generated with the according file name.

				Examplary rules:

				<programlisting><![CDATA[
LIST FirstNameList = 'FirstNames.twl';
DECLARE FirstName;
Document{-> MARKFAST(FirstName, FirstNameList)};
]]></programlisting>

				In this example, all first names in the given text file are again
				annotated in the input document with the type FirstName.

				Multi Tree
				Word List (.mtwl)
				A multi tree word list is generated using multiple
				.txt files and
				contains special nodes: Its nodes provide additional
				information
				about the original file. The .mtwl files are useful, if
				several
				different dictionaries are used in a TextMarker file. For
				five
				dictionaries, for example, also five MARKFAST rules are
				necessary.
				Therefore the matched text is searched five times and the
				complexity
				is 5 * O(m*log(n)). Using a .mtwl file reduces the
				complexity to
				about O(m*log(5*n)).

				Usage:
				A .mtwl file is generated
				using the popup menu. Select one or more
				.txt files (or a folder
				containing .txt files), click the right
				mouse button and choose
				''Convert to MTWL''. A .mtwl file named
				"generated.mtwl" is then
				generated that contains the word lists of
				all selected .txt files.
				Renaming the .mtwl file is recommended.


				If there are for example two
				or more word lists with the name
				"FirstNames.txt", "Companies.txt"
				and so on given and the generated
				.mtwl file is renamed to
				"Dictionary.mtwl", then the following rule
				annotates all companies
				and first names in the complete document.

				Examplary rules:

				<programlisting><![CDATA[
LIST Dictionary = 'Dictionary.mtwl';
DECLARE FirstName, Company;
Document{-> TRIE("FirstNames.txt" = FirstName, "Companies.txt" = Company, Dictionary, false, 0, false, 0, "")};
]]></programlisting>




				Table (.csv)
				The TextMarker system also supports .csv files,
				respectively tables.

				Usage:
				Content of a file named TestTable.csv
				(located in the resource folder of a
				TextMarker project):
				<programlisting><![CDATA[
Peter;P;
Jochen;J;
Joba;J;
]]></programlisting>

				Examplary rules:
				<programlisting><![CDATA[
PACKAGE de.uniwue.tm;
TABLE TestTable = 'TestTable.csv';
DECLARE Annotation Struct (STRING first);
Document{-> MARKTABLE(Struct, 1, TestTable, "first" = 2)};
]]></programlisting>
				In this example, the document is searched for all occurences of the
				entries of the first column of the given table, an annotation of the
				type Struct is created and its feature "first" is filled with the
				entry of the second column.

				For the input document with the content
				"Peter" the result is a single
				annotation of the type Struct and with
				P assigned to its features
				"first".

			</para>

		</section>
		<section id="ugr.tools.tm.parameters">
			<title>Parameters</title>
			<para>
				<itemizedlist>
					<listitem>
						<para>mainScript (String): This is the TextMarker script that
							will
							be loaded and executed by the generated engine. The string
							is
							referencing the name of the file without file extension but
							with
							its complete namespace, e.g., my.package.Main.
						</para>
					</listitem>

					<listitem>
						<para>scriptPaths (Multiple Strings): The given strings
							specify the
							folders that contain TextMarker script files, the
							main script file
							and the additional script files in particular.
							Currently, there is
							only one folder supported in the TextMarker
							workbench (script).
						</para>
					</listitem>

					<listitem>
						<para>enginePaths (Multiple Strings): The given strings
							specify the
							folders that contain additional analysis engines that
							are called
							from within a script file. Currently, there is only
							one folder
							supported in the TextMarker workbench (descriptor).
						</para>
					</listitem>

					<listitem>
						<para>resourcePaths (Multiple Strings): The given strings
							specify
							the folders that contain the word lists and dictionaries.
							Currently, there is only one folder supported in the TextMarker
							workbench (resources).

						</para>
					</listitem>

					<listitem>
						<para>additionalScripts (Multiple Strings): This parameter
							contains a list of all known script files references with their
							complete namespace, e.g., my.package.AnotherOne.
						</para>
					</listitem>

					<listitem>
						<para>additionalEngines (Multiple Strings): This parameter
							contains a list of all known analysis engines.
						</para>
					</listitem>

					<listitem>
						<para>additionalEngineLoaders (Multiple Strings): This
							parameter
							contains the class names of the implementations that
							help to load
							more complex analysis engines.

						</para>
					</listitem>

					<listitem>
						<para>scriptEncoding (String): The encoding of the script
							files.
							Not yet supported, please use UTF-8.
						</para>
					</listitem>

					<listitem>
						<para>defaultFilteredTypes (Multiple Strings): The complete
							names
							of the types that are filtered by default.
						</para>
					</listitem>

					<listitem>
						<para>defaultFilteredMarkups (Multiple Strings): The names of
							the
							markups that are filtered by default.

						</para>
					</listitem>

					<listitem>
						<para>seeders (Multiple Strings):
						</para>
					</listitem>

					<listitem>
						<para>useBasics (String):
						</para>
					</listitem>

					<listitem>
						<para>removeBasics (Boolean):

						</para>
					</listitem>

					<listitem>
						<para>debug (Boolean):
						</para>
					</listitem>

					<listitem>
						<para>profile (Boolean):
						</para>
					</listitem>

					<listitem>
						<para>debugWithMatches (Boolean):
						</para>
					</listitem>

					<listitem>
						<para>statistics (Boolean):
						</para>
					</listitem>

					<listitem>
						<para>debugOnlyFor (Multiple Strings):

						</para>
					</listitem>

					<listitem>
						<para>style (Boolean):
						</para>
					</listitem>

					<listitem>
						<para>styleMapLocation (String):
						</para>
					</listitem>
				</itemizedlist>
			</para>

		</section>
		<section id="ugr.tools.tm.query">
			<title>Query</title>
			<para>
				The query view can be used to write queries on several documents
				within a folder with the TextMArker language.

				A short example how to
				use the Query view:
				<itemizedlist>
					<listitem>
						<para> In the first field ''Query Data'', the folder is added in
							which the query is executed, for example with drag and drop from
							the script explorer. If the checkbox is activated, then all
							subfolder will be included in the query.
						</para>
					</listitem>
					<listitem>
						<para> The next field ''Type System'' must contain a type system
							or a TextMarker script that specifies all types that are used in
							the query.
						</para>
					</listitem>
					<listitem>
						<para> The query in form of one or more TextMarker rules is
							specified in the text field in the middle of the view. In the
							example of the screenshot, all ''Author'' annotations are
							selected that contain a ''FalsePositive'' or ''FalseNegative''
							annotation.
						</para>
					</listitem>
					<listitem>
						<para> If the start button near the tab of the view in the upper
							right corner ist pressed, then the results are displayed.
						</para>
					</listitem>
				</itemizedlist>
				<screenshot>
					<mediaobject>
						<imageobject>
							<imagedata scale="80" format="PNG" fileref="&imgroot;Query.png" />
						</imageobject>
						<textobject>
							<phrase>Query View</phrase>
						</textobject>
					</mediaobject>
				</screenshot>

			</para>
		</section>
		<section id="ugr.tools.tm.views">
			<title>Views</title>
			<para>

			</para>
			<section id="ugr.tools.tm.views.browser">
				<title>Annotation Browser</title>
				<para>
				</para>
			</section>
			<section id="ugr.tools.tm.views.editor">
				<title>Annotation Editor</title>
				<para>
				</para>
			</section>
			<section id="ugr.tools.tm.views.palette">
				<title>Marker Palette</title>
				<para>
				</para>
			</section>
			<section id="ugr.tools.tm.views.selection">
				<title>Selection</title>
				<para>
				</para>
			</section>

			<section id="ugr.tools.tm.views.stream">
				<title>Basic Stream</title>
				<para>
					The basic stream contains a listing of the complete disjunct
					partition
					of the document by the TextMarkerBasic annotation that are
					used for
					the inference and the annotation seeding.
				</para>
			</section>

			<section id="ugr.tools.tm.views.applied">
				<title>Applied Rules</title>
				<para>
					The Applied Rules views displays how often a rule tried to
					apply and
					how often the rule succeeded. Additionally some profiling
					information is added after a short verbalisation of the rule. The
					information is structured: if BLOCK constructs were used in the
					executed TextMarker file, the rules contained in that block will be
					represented as child node in the tree of the view. Each TextMarker
					file is itself a BLOCK construct named after the file. Therefore
					the root node of the view is always a BLOCK containing the rules of
					the executed TextMarker script. Additionally, if a rule calls a
					different TextMarker file, then the root block of that file is the
					child of that rule. The selection of a rule in this view will
					directly change the information visualized in the other views.

				</para>
			</section>
			<section id="ugr.tools.tm.views.selected">
				<title>Selected Rules</title>
				<para>
					This views is very similar to the Applied Rules view, but
					displays only
					rules and blocks under a given selection. If the user
					clicks on the
					document, then an Applied Rule view is generated
					containing only
					element that affect that position in the document.
					The Rule
					Elements view then only contains match information of that
					position, but the result of the rule element match is still
					displayed.
				</para>
			</section>

			<section id="ugr.tools.tm.views.rulelist">
				<title>Rule List</title>
				<para>
					This views is very similar to the Applied Rules view and the
					Selected
					Rules view, but displays only rules and NO blocks under
					a
					given
					selection. If the user clicks on the document, then a list
					of
					rules
					is generated that matched or tried to match on that
					position in
					the
					document. The Rule Elements view then only contains
					match
					information of that position, but the result of the rule
					element
					match is still displayed. Additionally, this view provides a
					text
					field for filtering the rules. Only those rules remain that
					contain
					the entered text in their verbalization.
				</para>
			</section>

			<section id="ugr.tools.tm.views.matched">
				<title>Matched Rules</title>
				<para>
					If a rule is selected in the Applied Rules views, then this
					view
					displays the instances (text passages) where this rules
					matched.
				</para>
			</section>

			<section id="ugr.tools.tm.views.failed">
				<title>Failed Rules</title>
				<para>
					If a rule is selected in the Applied Rules views, then this
					view
					displays the instances (text passages) where this rules failed
					to
					match.
				</para>
			</section>

			<section id="ugr.tools.tm.views.elements">
				<title>Rule Elements</title>
				<para>
					If a successful or failed rule match in the Matched Rules view
					or
					Failed Rules view is selected, then this views contains a listing
					of the rule elements and their conditions. There is detailed
					information available on what text each rule element matched and
					which condition did evavaluate true.
				</para>
			</section>

			<section id="ugr.tools.tm.views.statistics">
				<title>Statistics</title>
				<para>
					This views displays the used conditions and actions of the
					TextMarker
					language. Three numbers are given for each element: The
					total time
					of execution, the amount of executions and the time per
					execution.
				</para>
			</section>
			<section id="ugr.tools.tm.views.fp">
				<title>False Positive</title>
				<para>
				</para>
			</section>

			<section id="ugr.tools.tm.views.fn">
				<title>False Negative</title>
				<para>
				</para>
			</section>

			<section id="ugr.tools.tm.views.tp">
				<title>True Positive</title>
				<para>

				</para>
			</section>
		</section>
		<section id="ugr.tools.tm.testing">
			<title>Testing</title>
			<para>
				The TextMarker Software comes bundled with its own testing
				environment,
				that allows you to test and evaluate TextMarker scripts.
				It provides
				full back end testing capabilities and allows you to
				examine test
				results in detail. As a product of the testing operation
				a new
				document file will be created and detailed information on how
				well
				the script performed in the test will be added to this document.
			</para>
			<section id="ugr.tools.tm.testing.overview">
				<title>Overview</title>
				<para>
					The testing procedure compares a previously annotated gold standard
					file with the result of the selected TextMarker script using an
					evaluator. The evaluators compare the offsets of annotations in
					both documents and, depending on the evaluator, mark a result
					document with true positive, false positive or false negative
					annotations. Afterwards the f1-score is calculated for the whole
					set of tests, each test file and each type in the test file.
					The testing environment contains the following parts :
					<itemizedlist>
						<listitem>
							<para>Main view</para>
						</listitem>
						<listitem>
							<para>Result views : true positive, false positive, false
								negative view
							</para>
						</listitem>
						<listitem>
							<para>Preference page</para>
						</listitem>
					</itemizedlist>
					<screenshot>
						<mediaobject>
							<imageobject>
								<imagedata scale="80" format="PNG"
									fileref="&imgroot;Screenshot_main.png" />
							</imageobject>
							<textobject>
								<phrase>Eclipse with open TextMarker and testing environment.
								</phrase>
							</textobject>
						</mediaobject>
					</screenshot>
					All control elements,that are needed for the interaction with the
					testing environment, are located in the main view.
					This is also
					where test files can be selected and information, on how
					well the
					script performed is, displayed. During the testing process
					a result
					CAS file is produced that will contain new
					annotation types like
					true positives (tp), false positives (fp) and false
					negatives (fn).
					While displaying the result .xmi file in the script
					editor,
					additional
					views allow easy navigation through the new annotations.
					Additional tree
					views, like the true positive view, display the
					corresponding
					annotations in a
					hierarchic structure. This allows an
					easy tracing of the results inside the
					testing document. A
					preference page allows customization of the
					behavior
					of the testing
					plug-in.
				</para>
				<section id="ugr.tools.tm.testing.overview.main">
					<title>Main View</title>
					<para>
						The following picture shows a close up view of the testing
						environments main-view part. The toolbar contains all buttons
						needed to operate the plug-ins. The first line shows the name of
						the script that is going to be tested and a combo-box, where the
						view, that should be tested, is selected. On the right follow
						fields that will show some basic information of the results of the
						test-run.
						Below and on the left the test-list is located. This list
						contains the
						different test-files. Right besides it, you will find
						a table with
						statistic information. It shows a total tp, fp and fn
						information,
						as well as precision, recall and f1-score of every
						test-file and
						for every type in each file.
						<screenshot>
							<mediaobject>
								<imageobject>
									<imagedata scale="80" format="PNG"
										fileref="&imgroot;Screenshot_testing_desc_3_resize.png" />
								</imageobject>
								<textobject>
									<phrase>The main view of the testing environment.</phrase>
								</textobject>
							</mediaobject>
						</screenshot>
					</para>
				</section>
				<section id="ugr.tools.tm.testing.overview.result">
					<title>Result Views</title>
					<para>
						This views add additional information to the CAS View, once a
						result file is opened. Each view displays one of the following
						annotation types in a hierarchic tree structure : true positives,
						false positive and false negative. Adding a check mark to one of
						the annotations in a result view, will highlight the annotation in
						the CAS Editor.
						<screenshot>
							<mediaobject>
								<imageobject>
									<imagedata scale="80" format="PNG"
										fileref="&imgroot;Screenshot_result.png" />
								</imageobject>
								<textobject>
									<phrase>The main view of the testing environment.</phrase>
								</textobject>
							</mediaobject>
						</screenshot>
					</para>
				</section>
				<section id="ugr.tools.tm.testing.overview.preferences">
					<title>Preference Page</title>
					<para>
						The preference page offers a few options that will modify the
						plug-ins general behavior. For example the preloading of
						previously collected result data can be turned off, should it
						produce a to long loading time. An important option in the
						preference page is the evaluator you can select. On default the
						"exact evaluator" is selected, which compares the offsets of the
						annotations, that are contained in the file produced by the
						selected script, with the annotations in the test file. Other
						evaluators will compare annotations in a different way.
						<screenshot>
							<mediaobject>
								<imageobject>
									<imagedata scale="80" format="PNG"
										fileref="&imgroot;Screenshot_preferences.png" />
								</imageobject>
								<textobject>
									<phrase>The preference page of the testing environment.
									</phrase>
								</textobject>
							</mediaobject>
						</screenshot>
					</para>
				</section>
				<section id="ugr.tools.tm.testing.overview.project">
					<title>The TextMarker Project Structure</title>
					<para>
						The picture shows the TextMarker's script explorer. Every
						TextMarker project contains a folder called "test". This folder is
						the default location for the test-files. In the folder each
						script-file has its own sub-folder with a relative path equal to
						the scripts package path in the "script" folder. This folder
						contains the test files. In every scripts test-folder you will
						also find a result folder with the results of the tests. Should
						you use test-files from another location in the file-system, the
						results will be saved in the "temp" sub-folder of the projects
						"test" folder. All files in the "temp" folder will be deleted,
						once eclipse is closed.
						<screenshot>
							<mediaobject>
								<imageobject>
									<imagedata scale="80" format="PNG"
										fileref="&imgroot;folder_struc_sep_desc_cut.png" />
								</imageobject>
								<textobject>
									<phrase>Script Explorer with the test folder expanded.</phrase>
								</textobject>
							</mediaobject>
						</screenshot>
					</para>
				</section>
			</section>
			<section id="ugr.tools.tm.testing.usage">
				<title>Usage</title>
				<para>
					This section will demonstrate how to use the testing
					environment.
					It will show the basic actions needed to perform a test
					run.
				</para>
				<para>
					Preparing Eclipse:
					The testing environment provides its own
					perspective called
					"TextMarker Testing". It will display the main
					view as well as the
					different result views on the right hand side.
					It is encouraged to
					use this perspective, especially when working
					with the testing
					environment for the first time.
				</para>
				<para>
					Selecting a script for testing:
					TextMarker will always test the
					script, that is currently open in the
					script-editor. Should another
					editor be open, for example a
					java-editor with some java class being
					displayed, you will see that
					the testing view is not available.
				</para>
				<para>
					Creating a test file:
					A test-file is a previously annotated
					.xmi file that can be used as
					a golden standard for the test. To
					create such a file, no
					additional tools will be provided, instead
					the TextMarker system
					already provides such tools.
				</para>
				<para>
					Selecting a test-file:
					Test files can be added to the test-list
					by simply dragging them from
					the Script Explorer into the test-file
					list. Depending on the
					setting in the preference page, test-files
					from a scripts "test"
					folder might already be loaded into the list.
					A different way to
					add test-files is to use the "Add files from
					folder" button. It can
					be used to add all .xmi files from a selected
					folder. The "del" key
					can be used to remove files from the
					test-list.
				</para>
				<para>
					Selecting a CAS View to test:
					TextMarker supports different
					views, that allow you to operate on different
					levels in a document.
					The InitialView is selected as default,
					however you can also switch
					the evaluation to another view by
					typing the views name into the
					list or selecting the view you wish
					to use from the list.
				</para>
				<para>
					Selecting the evaluator:
					The testing environment supports
					different evaluators that allow a
					sophisticated analysis of the
					behavior of a TextMarker script. The
					evaluator can be chosen in the
					testing environments preference
					page. The preference page can be
					opened either trough the menu or
					by clicking the blue preference
					buttons in the testing views
					toolbar. The default evaluator is the
					"Exact CAS Evaluator" which
					compares the offsets of the annotations
					between the test file and
					the file annotated by the tested script.
				</para>
				<para>
					Excluding Types:
					During a test-run it might be convenient to
					disable testing for specific
					types like punctuation or tags. The
					''exclude types`` button will
					open a dialog where all types can be
					selected that should not be
					considered in the test.
				</para>
				<para>
					Running the test:
					A test-run can be started by clicking on the
					green start button in
					the toolbar.
				</para>
				<para>
					Result Overview:
					The testing main view displays some
					information, on how well the
					script did, after every test run. It
					will display an overall number
					of true positive, false positive and
					false negatives annotations of
					all result files as well as an
					overall f1-score. Furthermore a
					table will be displayed that
					contains the overall statistics of the
					selected test file as well as
					statistics for every single type in
					the test file. The information
					displayed are true positives, false
					positives, false negatives,
					precision, recall and f1-measure.
				</para>
				<para>
					The testing environment also supports the export of the
					overall data
					in form of a comma-separated table. Clicking the export
					evaluation
					data will open a dialog window that contains this table.
					The text
					in this table can be copied and easily imported into
					OpenOffice.org
					or MS Excel.
				</para>
				<para>
					Result Files:
					When running a test, the evaluator will create a new
					result .xmi file
					and will add new true positive, false positive and
					false negative
					annotations. By clicking on a file in the test-file
					list, you can
					open the corresponding result .xmi file in the
					TextMarker script
					editor. When opening a result file in the script
					explorer,
					additional views will open, that allow easy access and
					browsing of
					the additional debugging annotations.
					<screenshot>
						<mediaobject>
							<imageobject>
								<imagedata scale="80" format="PNG"
									fileref="&imgroot;Screenshot_Result_TP_desc_close_cut.png" />
							</imageobject>
							<textobject>
								<phrase>Open result file and selected true positive annotation
									in the true positive view.
								</phrase>
							</textobject>
						</mediaobject>
					</screenshot>
				</para>
			</section>
			<section id="ugr.tools.tm.testing.evaluators">
				<title>Evaluators</title>
				<para>
					When testing a CAS file, the system compared the offsets of
					the
					annotations of a previously annotated gold standard file with
					the
					offsets of the annotations
					of the result file the script
					produced. Responsible for comparing
					annotations in the two CAS files
					are evaluators. These evaluators
					have different methods
					and
					strategies, for comparing the annotations, implemented. Also a
					extension point is provided that allows easy implementation new
					evaluators.
				</para>
				<para>
					Exact Match Evaluator:
					The Exact Match Evaluator compares the
					offsets of the annotations in
					the result and the golden standard
					file. Any difference will be
					marked with either an false positive or
					false negative annotations.
				</para>
				<para>
					Partial Match Evaluator:
					The Partial Match Evaluator compares
					the offsets of the annotations in
					the result and golden standard
					file. It will allow differences in
					the beginning or the end of an
					annotation. For example "corresponding" and "corresponding " will
					not be
					annotated as an error.
				</para>
				<para>
					Core Match Evaluator:
					The Core Match Evaluator accepts
					annotations that share a core
					expression. In this context a core
					expression is at least four
					digits long and starts with a
					capitalized letter. For example the
					two annotations "L404-123-421"
					and "L404-321-412" would be
					considered a true positive match,
					because of "L404" is considered a
					core expression that is contained
					in both annotations.
				</para>
				<para>
					Word Accuracy Evaluator:
					Compares the labels of all
					words/numbers in an annotation, whereas the
					label equals the type of
					the annotation. This has the consequence,
					for example, that each
					word or number that is not part of the
					annotation is counted as a
					single false negative. For example we
					have the sentence: "Christmas
					is on the 24.12 every year."
					The script labels "Christmas is on the
					12" as a single sentence, while
					the test file labels the sentence
					correctly with a single sentence
					annotation. While for example the
					Exact CAS Evaluator while only
					assign a single False Negative
					annotation, Word Accuracy Evaluator
					will mark every word or number
					as a single False Negative.
				</para>
				<para>
					Template Only Evaluator:
					This Evaluator compares the offsets of
					the annotations and the
					features, that have been created by the
					script. For example the
					text "Alan Mathison Turing" is marked with
					the author annotation
					and "author" contains 2 features: "FirstName"
					and "LastName". If
					the script now creates an author annotation with
					only one feature,
					the annotation will be marked as a false positive.
				</para>
				<para>
					Template on Word Level Evaluator:
					The Template On Word
					Evaluator compares the offsets of the
					annotations. In addition it
					also compares the features and feature
					structures and the values
					stored in the features. For example the
					annotation "author" might
					have features like "FirstName" and
					"LastName" The authors name is
					"Alan Mathison Turing" and the
					script correctly assigns the author
					annotation. The feature
					assigned by the script are "Firstname :
					Alan", "LastName :
					Mathison", while the correct feature values would
					be "FirstName
					Alan", "LastName Turing". In this case the Template
					Only Evaluator
					will mark a annotation as a false positive, since the
					feature
					values differ.
				</para>
			</section>

		</section>
		<section id="ugr.tools.tm.textruler">
			<title>TextRuler</title>
			<para>
				Using the knowledge engineering approach, a knowledge engineer
				normally
				writes handcrafted rules to create a domain dependent
				information
				extraction application, often supported by a gold
				standard. When
				starting the engineering process for the acquisition
				of the
				extraction knowledge for possibly new slot or more general for
				new
				concepts, machine learning methods are often able to offer
				support
				in an iterative engineering process. This section gives a
				conceptual
				overview of the process model for the semi-automatic
				development of
				rule-based information extraction applications.
			</para>
			<para>
				First, a suitable set of documents that contain the text
				fragments with
				interesting patterns needs to be selected and
				annotated with the
				target concepts. Then, the knowledge engineer
				chooses and configures
				the methods for automatic rule acquisition to
				the best of his
				knowledge for the learning task: Lambda expressions
				based on tokens
				and linguistic features, for example, differ in their
				application
				domain from wrappers that process generated HTML pages.
			</para>
			<para>
				Furthermore, parameters like the window size defining relevant
				features need to
				be set to an appropriate level. Before the annotated
				training
				documents form the input of the learning task, they are
				enriched
				with features generated by the partial rule set of the
				developed
				application. The result of the methods, that is the learned
				rules,
				are proposed to the knowledge engineer for the extraction of
				the
				target concept.
			</para>
			<para>
				The knowledge engineer has different options to proceed: If the
				quality, amount or generality of the presented rules is not
				sufficient, then additional training documents need to be annotated
				or additional rules have to be handcrafted to provide more features
				in general or more appropriate features. Rules or rule sets of high
				quality can be modified, combined or generalized and transfered to
				the rule set of the application in order to support the extraction
				task of the target concept. In the case that the methods did not
				learn reasonable rules at all, the knowledge engineer proceeds with
				writing handcrafted rules.
			</para>
			<para>
				Having gathered enough extraction knowledge for the current
				concept, the
				semi-automatic process is iterated and the focus is
				moved to the
				next concept until the development of the application is
				completed.
			</para>
			<section id="ugr.tools.tm.textruler.learner">
				<title>Available Learners</title>
				<para>
					Overview

					||Name||Strategy||Document||Slots||Status
					|BWI (1)
					|Boosting, Top Down |Struct, Semi |Single, Boundary |Planning
					|LP2
					(2) |Bottom Up Cover |All |Single, Boundary |Prototype
					|RAPIER (3)
					|Top Down/Bottom Up Compr. |Semi |Single |Experimental
					|WHISK (4)
					|Top Down Cover |All |Multi |Prototype
					|WIEN (5) |CSP |Struct
					|Multi, Rows |Prototype
				</para>
				<para>
					* Strategy: The used strategy of the learning methods are
					commonly
					coverage algorithms.
					* Document: The type of the document
					may be ''free'' like in
					newspapers, ''semi'' or ''struct'' like HTML
					pages.
					* Slots: The slots refer to a single annotation that
					represents the
					goal of the learning task. Some rule are able to
					create several
					annotation at once in the same context (multi-slot).
					However, only
					single slots are supported by the current
					implementations.
					* Status: The current status of the implementation
					in the TextRuler
					framework.
				</para>
				<para>
					Publications
				</para>
				<para>
					(1) Dayne Freitag and Nicholas Kushmerick. Boosted Wrapper
					Induction.
					In AAAI/IAAI, pages 577583, 2000.
				</para>
				<para>
					(2) F. Ciravegna. (LP)2, Rule Induction for Information
					Extraction
					Using Linguistic Constraints. Technical Report CS-03-07,
					Department
					of Computer Science, University of Sheffield, Sheffield,
					2003.
				</para>
				<para>
					(3) Mary Elaine Califf and Raymond J. Mooney. Bottom-up
					Relational
					Learning of Pattern Matching Rules for Information
					Extraction.
					Journal of Machine Learning Research, 4:177210, 2003.
				</para>
				<para>
					(4) Stephen Soderland, Claire Cardie, and Raymond Mooney.
					Learning
					Information Extraction Rules for Semi-Structured and Free
					Text. In
					Machine Learning, volume 34, pages 233272, 1999.
				</para>
				<para>
					(5) N. Kushmerick, D. Weld, and B. Doorenbos. Wrapper
					Induction for
					Information Extraction. In Proc. IJC Artificial
					Intelligence, 1997.
				</para>
				<para>
					BWI
					BWI (Boosted Wrapper Induction) uses boosting techniques to
					improve
					the performance of simple pattern matching single-slot
					boundary
					wrappers (boundary detectors). Two sets of detectors are
					learned:
					the "fore" and the "aft" detectors. Weighted by their
					confidences
					and combined with a slot length histogram derived from
					the training
					data they can classify a given pair of boundaries
					within a
					document. BWI can be used for structured, semi-structured
					and free
					text. The patterns are token-based with special wildcards
					for more
					general rules.
				</para>
				<para>
					Implementations
					No implementations are yet available.
				</para>
				<para>
					Parameters
					No parameters are yet available.

				</para>
				<para>
					LP2
					This method operates on all three kinds of documents. It
					learns
					separate rules for the beginning and the end of a single
					slot. So
					called tagging rules insert boundary SGML tags and
					additionally
					induced correction rules shift misplaced tags to their
					correct
					positions in order to improve precision. The learning
					strategy is a
					bottom-up covering algorithm. It starts by creating a
					specific seed
					instance with a window of w tokens to the left and
					right of the
					target boundary and searches for the best
					generalization. Other
					linguistic NLP-features can be used in order
					to generalize over the
					flat word sequence.
				</para>
				<para>
					Implementations
					LP2 (naive):
					LP2 (optimized):
				</para>
				<para>
					Parameters
					Context Window Size (to the left and right):
					Best
					Rules List Size:
					Minimum Covered Positives per Rule:
					Maximum Error
					Threshold:
					Contextual Rules List Size:
				</para>
				<para>
					RAPIER
					RAPIER induces single slot extraction rules for
					semi-structured
					documents. The rules consist of three patterns: a
					pre-filler, a
					filler and a post-filler pattern. Each can hold
					several constraints
					on tokens and their according POS-tag- and
					semantic information.
					The algorithm uses a bottom-up compression
					strategy, starting with
					a most specific seed rule for each training
					instance. This initial
					rule base is compressed by randomly selecting
					rule pairs and search
					for the best generalization. Considering
					two
					rules, the least general generalization (LGG) of the slot fillers
					are created and specialized by adding rule items to the pre- and
					post-filler until the new rules operate well on the training set.
					The best of the k rules (k-beam search) is added to the rule base
					and all empirically subsumed rules are removed.
				</para>
				<para>
					Implementations
					RAPIER:
				</para>
				<para>
					Parameters
					Maximum Compression Fail Count:
					Internal Rules List
					Size:
					Rule Pairs for Generalizing:
					Maximum 'No improvement' Count:
					Maximum Noise Threshold:
					Minimum Covered Positives Per Rule:
					PosTag
					Root Type:
					Use All 3 GenSets at Specialization:
				</para>
				<para>
					WHISK
					WHISK is a multi-slot method that operates on all three
					kinds of
					documents and learns single- or multi-slot rules looking
					similar to
					regular expressions. The top-down covering algorithm
					begins with
					the most general rule and specializes it by adding
					single
					rule terms until the rule makes no errors on the training
					set. Domain
					specific classes or linguistic information obtained by a
					syntactic
					analyzer can be used as additional features. The exact
					definition
					of a rule term (e.g. a token) and of a problem instance
					(e.g. a
					whole document or a single sentence) depends on the
					operating
					domain and document
					type.
				</para>
				<para>
					Implementations
					WHISK (token):
					WHISK (generic):
				</para>
				<para>
					Parameters
					Window Size:
					Maximum Error Threshold:
					PosTag Root
					Type:
				</para>
				<para>
					WIEN
					WIEN is the only method listed here that operates on
					highly structured
					texts only. It induces so called wrappers that
					anchor the slots by
					their structured context around them. The HLRT
					(head left right
					tail) wrapper class for example can determine and
					extract
					several multi-slot-templates by first separating the
					important information
					block from unimportant head and tail portions
					and then extracting
					multiple data rows from table like
					data
					structures from the remaining document. Inducing a wrapper is done
					by solving a CSP for all possible pattern combinations from the
					training data.
				</para>
				<para>
					Implementations
					WIEN:
				</para>
				<para>
					Parameters
					No parameters are available.

				</para>
			</section>
		</section>

	</section>
</chapter>